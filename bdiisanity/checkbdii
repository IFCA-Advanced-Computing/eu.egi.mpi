#!/usr/bin/env python
##############################################################################
#
# NAME:
#
# FACILITY:
#
# COPYRIGHT:
#
# DESCRIPTION:
#         MPI BDII Sanity check.
#
# AUTHORS:     Enol Fernandez, IFCA-CSIC based on Goncalo Borges perl code
#
# CREATED:     16-Jun-2012
#
# NOTES:
#
# MODIFIED:
#
##############################################################################

import os
import re
import sys
import datetime
from urllib2 import urlopen
from xml.dom.minidom import parse

# nagios exit codes
NAGIOS_OK = 0
NAGIOS_WARN = 1
NAGIOS_CRIT = 2
NAGIOS_UNK = 3

# Some LONG Strings
RTE = 'GlueHostApplicationSoftwareRunTimeEnvironment'
GOCDB_METHOD = ("/public/?method=get_site_list&certification_status"
                "=Certified&production_status=Production")
# Policies
MAX_CPUT = 'GlueCEPolicyMaxCPUTime'
MAX_SLOTS = 'GlueCEPolicyMaxSlotsPerJob'
MAX_WALLT = 'GlueCEPolicyMaxWallClockTime'
MAX_RUNJOBS = 'GlueCEPolicyMaxRunningJobs'
MAX_TOTALJOBS = 'GlueCEPolicyMaxTotalJobs'
ASSIGNED_JOBS = 'GlueCEPolicyAssignedJobSlots'
BIG_NUMBER = 999999998


ext_output = []
warn_output = ''
error_output = ''

try:
    import ldap
except ImportError:
    print "CRITICAL: ldap module not found"
    sys.exit(NAGIOS_CRIT)


class UnexpectedException(Exception):
    pass


def ldap_wrapper(f):
    def call_ldap(*args):
        try:
            l = ldap.initialize(config['bdii_url'])
            return f(l, *args)
        except ldap.LDAPError, e:
            print ("UNKNOWN Error when trying to"
                   "connect to %s: %s") % (config['bdii_url'], e)
            sys.exit(NAGIOS_UNK)
    return call_ldap


# Default configuration
config = {
    "bdii_url": "ldap://topbdii.core.ibergrid.eu:2170",
    "bdii_base": "o=grid",
    "flavors": ["MPICH", "MPICH2", "OPENMPI"],
    "gocdb_url": "https://goc.egi.eu/gocdbpi",
    "timeout": 30,
}


def add_output(msg):
    global ext_output
    ext_output.append(msg)


def set_error(errmsg):
    global error_output
    error_output = errmsg
    add_output(errmsg)


def set_warning(warnmsg):
    global warn_output
    warn_output = warnmsg
    add_output(warnmsg)


def validate_flavor_tags(flv, env):
    flavor_name = False
    flavor_version = False
    r = re.compile('^%s(-\S+)?$' % flv)
    tags = []
    for e in env:
        res = r.match(e)
        if res:
            if res.groups()[0]:
                flavor_version = True
                tags.append(e)
            else:
                flavor_name = True
                tags.append(e)
    if tags:
        add_output('Found tags %s for flavor %s'
                   % (', '.join(tags), flv))
    if flavor_name and not flavor_version:
        set_warning('Does not publish %s version' % flv)
    return flavor_name


def validate_mpi_env(env):
    has_flavors = False
    for flv in config['flavors']:
        has_flavors |= validate_flavor_tags(flv, env)
    mpi_start_tags = [m for m in env if m.find('MPI-START') == 0]
    if not mpi_start_tags:
        set_error('Does not publish MPI-START tag!')
    else:
        add_output('Found tag %s for MPI-START' % ', '.join(mpi_start_tags))
    if not has_flavors:
        set_error('Does not publish any MPI flavors!')


def get_policy_value(ce, pcy):
    if config['verbose']:
        print "Checking policy %s" % pcy
    try:
        v = int(ce[pcy][0])
        if config['verbose']:
            print "Found value %d" % v
        add_output('Found value %d for policy %s' % (v, pcy))
        return v
    except KeyError:
        set_error('does not publish %s' % pcy)
    except ValueError:
        set_error('publishes incorrect value for %s (%s)' % (pcy, ce[pcy][0]))


def validate_time_policies(max_wc_time, max_cpu_time):
    if max_wc_time == 0:
        set_warning('Publishes an incorrect value for %s (%d)'
                    % (MAX_WALLT, max_wc_time))
    if max_cpu_time == 0:
        set_warning('Publishes an incorrect value for %s (%d)'
                    % (MAX_CPUT, max_cpu_time))
    if max_wc_time > BIG_NUMBER and max_cpu_time > BIG_NUMBER:
        set_warning('Publishes incorrect limits on cpu (%s)'
                    ' or wall clock time (%s)' % (MAX_CPUT, MAX_WALLT))
    if max_wc_time != 0 and max_cpu_time / max_wc_time < 4:
        set_warning("Publishes %s (%d) / %s (%d) < 4"
                    % (MAX_CPUT, max_wc_time, MAX_WALLT, max_cpu_time))


def validate_slots_policies(max_slots):
    if max_slots == 0 or max_slots == 1 or max_slots > BIG_NUMBER:
        set_warning('Publishes an incorrect value for %s (%d)' %
                    (MAX_SLOTS, max_slots))


def validate_policies(ce):
    if config['verbose']:
        print "Checking policies for %s" % ce['GlueCEUniqueID'][0]
    max_wc_time = get_policy_value(ce, MAX_WALLT)
    max_cpu_time = get_policy_value(ce, MAX_CPUT)
    max_slots = get_policy_value(ce, MAX_SLOTS)
    validate_time_policies(max_wc_time, max_cpu_time)
    validate_slots_policies(max_slots)


@ldap_wrapper
def get_srte_ce(l, ce):
    f = '(&(&(objectClass=GlueCE)(GlueCEInfoHostName=%s))' % ce
    f += ('(|(GlueCEAccessControlBaseRule=VO:%(vo)s)'
          '(GlueCEAccessControlBaseRule=VOMS:/%(vo)s/*)))') % config
    entries = l.search_st('o=grid', ldap.SCOPE_SUBTREE, f,
                          ['GlueForeignKey'])
    if not entries:
        raise UnexpectedException('Unable to get site name for %s' % ce)
    # assume the first entry is good if we have more than one CE
    site = [e for e in entries[0][1]['GlueForeignKey']
            if e.find('GlueClusterUniqueID') == 0][0]
    if not site:
        raise UnexpectedException('Unable to get site name for %s' % ce)
    # search
    entries = l.search_st('o=grid', ldap.SCOPE_SUBTREE,
                          '(&(objectClass=GlueSubCluster)(GlueChunkKey=%s))'
                          % site, [RTE])
    if not entries:
        raise UnexpectedException('Unable to get cluster info for site %s'
                                  % site)
    return entries


@ldap_wrapper
def get_pcy_ce(l, ce):
    f = '(&(&(objectClass=GlueCE)(GlueCEInfoHostName=%s))' % ce
    f += ('(|(GlueCEAccessControlBaseRule=VO:%s)'
          '(GlueCEAccessControlBaseRule=VOMS:/%s/*)))') % (config['vo'],
                                                           config['vo'])
    r = l.search_st('o=grid', ldap.SCOPE_SUBTREE, f,
                    [MAX_RUNJOBS, MAX_TOTALJOBS, MAX_SLOTS, MAX_WALLT,
                     ASSIGNED_JOBS, MAX_CPUT, 'GlueCEUniqueID'])
    if not r:
        raise UnexpectedException('Unable to get policy info for %s' % ce)
    return r


@ldap_wrapper
def get_pcy_cluster(l, cluster):
    f = ('(&(&(objectClass=GlueCE)'
         '(GlueForeignKey=GlueClusterUniqueID=%s))') % cluster
    f += ('(|(GlueCEAccessControlBaseRule=VO:%s)'
          '(GlueCEAccessControlBaseRule=VOMS:/%s/*)))') % (config['vo'],
                                                           config['vo'])
    r = l.search_st('o=grid', ldap.SCOPE_SUBTREE, f,
                    [MAX_RUNJOBS, MAX_TOTALJOBS, MAX_SLOTS, MAX_WALLT,
                     ASSIGNED_JOBS, MAX_CPUT, 'GlueCEUniqueID'])
    if not r:
        raise UnexpectedException('Unable to get policy info for %s' % cluster)
    return r


@ldap_wrapper
def get_srte_site(l, site):
    entries = l.search_st(config['bdii_base'], ldap.SCOPE_SUBTREE,
                          ('(&(objectclass=GlueCluster)'
                           '(GlueForeignKey=GlueSiteUniqueID=%s))') % site,
                          ['GlueClusterUniqueID'])
    if not entries:
        raise UnexpectedException('Unable to get Cluster IDs for site %s'
                                  % site)
    for e in entries:
        cluster_id = e[1]['GlueClusterUniqueID'][0]
    r = l.search_st(config['bdii_base'], ldap.SCOPE_SUBTREE,
                    ('(&(objectclass=GlueSubCluster)'
                     '(GlueChunkKey=GlueClusterUniqueID=%s))') % cluster_id,
                    [RTE])
    if not r:
        raise UnexpectedException('Unable to get RTE info for site %s' % site)
    return r, cluster_id


def validate_site_ces(site):
    try:
        if config['verbose']:
            print "Checking SITE %s" % site
        srte, cluster = get_srte_site(site)
        validate_mpi_env(srte[0][1][RTE])
        pcy = get_pcy_cluster(cluster)
        for ce in pcy:
            validate_policies(ce[1])
    except UnexpectedException, e:
        print "Unexpected error: %s %s" % (site, e)
        sys.exit(NAGIOS_UNK)


def get_gocdb_sites():
    if config['verbose']:
        print ("Connecting to %s to fetch site list"
               % ''.join((config["gocdb_url"], GOCDB_METHOD)))
    f = urlopen(config["gocdb_url"] + GOCDB_METHOD)   # , timeout=15)
    d = parse(f)
    return [s.getAttribute("NAME") for s in d.getElementsByTagName("SITE")]


def validate_ce(ce):
    global exit_code
    try:
        if config['verbose']:
            print "Checking CE %s" % ce
        srte = get_srte_ce(ce)
        validate_mpi_env(srte[0][1][RTE])
        pcy = get_pcy_ce(ce)
        validate_policies(pcy[0][1])
    except UnexpectedException, e:
        print "Unknown error when checking %s: %s" % (ce, e)
        sys.exit(NAGIOS_UNK)


from optparse import OptionParser

parser = OptionParser()
parser.add_option('-v', '--verbose', dest='verbose',
                  help='be verbose', action='store_true', default=False)
parser.add_option('-H', '--hostname', dest='hostname',
                  help='test host HOSTNAME', metavar='HOSTNAME')
parser.add_option('-a', '--all', action='store_true', default=False,
                  help='Test all the sites in GOCDB', dest='all')
parser.add_option('-V', '--vo', default='ops', dest='vo',
                  help='Test info for VO', metavar='VO')
parser.add_option('-t', '--timeout', dest='timeout', default=config['timeout'],
                  help='set timeout value to TIMEOUT', metavar='TIMEOUT')
parser.add_option('-f', '--flavor', dest='flavors', default=[],
                  help='test specific MPI flavor', metavar='FLAVOR',
                  action="append")
parser.add_option('-b', '--bdii', dest='bdii_host',
                  help='use BDII_HOST (with port!) for queries',
                  metavar='BDII_HOST',)
(options, args) = parser.parse_args()

if options.flavors:
    config['flavors'] = options.flavors
if options.verbose:
    print "Executing MPI BDII Sanity check (%s)" % datetime.datetime.now()
    print "Will test %s flavors" % ', '.join(config['flavors'])
config['timeout'] = options.timeout
config['verbose'] = options.verbose
config['vo'] = options.vo

if options.bdii_host:
    config['bdii_url'] = 'ldap://%s' % (options.bdii_host)
else:
    try:
        bdii = os.environ['LCG_GFAL_INFOSYS'].split(',')[0]
        config['bdii_url'] = 'ldap://%s' % (bdii)
    except KeyError:
        pass

if options.all and options.hostname:
    parser.error('-a and -H options cannot be used simultaneously')
else:
    if options.all:
        if config['verbose']:
            print "Testing all sites in GOCDB"
        for site in get_gocdb_sites():
            validate_site_ces(site)
    elif options.hostname:
        validate_ce(options.hostname)
    else:
        parser.error('Specify -a or -H options')

if error_output:
    exit_code = NAGIOS_CRIT
elif warn_output:
    exit_code = NAGIOS_WARN
else:
    print 'MPI related BDII Values OK'
    exit_code = NAGIOS_OK

if error_output:
    print 'CRITICAL: %s' % error_output
if warn_output:
    print 'WARNING: %s' % warn_output
if ext_output:
    print '\n'.join(ext_output)
sys.exit(exit_code)
